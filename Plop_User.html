<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Plop User's Guide </TITLE>
</HEAD>
<BODY>

<FONT FACE="Arial Black" SIZE=6><P>Plop User's Guide</P>
</FONT><FONT FACE="Arial" SIZE=5><P>David Lewis</FONT><FONT FACE="Arial" SIZE=2> </P>
<P>Rev 1.1, Oct. 4 1998</P>
</FONT><FONT FACE="Arial Black" SIZE=6>
<OL>

</FONT><FONT FACE="Arial Black" COLOR="#ffffff"><LI>Introduction</LI></OL>

</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Plop is a program written by David Lewis and Toshimi Taki for the design and optimization of mirror cells. Plop is an abbreviation of Plate Optimizer. Plate is a tool written by Toshimi Taki that uses the finite element method (FEM) to analyze the deformation of plates under loads. Toshimi published his results in Sky and Telescope in April, 1996. Plate was written in about 800 lines of Fortran, and required that the user manually design the mesh to approximate the mirror as a set of small triangular pieces. Plate's output is also a table of numerical values giving the deformation of each point. This numerical input and output makes it difficult to prepare the input, and requires further analysis of the output of the program.</P>
<P ALIGN="JUSTIFY">David Lewis began with Toshimi's Plate code, and expanded around it into Plop. Plop adds several features to extend the range of functionality and increase the ease of use, so that a designer can quickly test or optimize a cell design without knowing the details of FEM. In particular, Plop includes:</P>

<UL>
<P ALIGN="JUSTIFY"><LI>Automatic generation of the mesh from a few parameters, such as diameter, thickness, focal length, and the location of the mirror supports.</LI></P>
<P ALIGN="JUSTIFY"><LI>Accurate error calculation of the deformation of the mirror, including the ability of the user to refocus the telescope to its best focus.</LI></P>
<P ALIGN="JUSTIFY"><LI>Faster numerical methods, in particular the use of sparse matrix methods, and generation of the mesh in a way that reduces matrix fillins.</LI></P>
<P ALIGN="JUSTIFY"><LI>Graphical output of the mirror deformation as either a contour or color plot. This includes .gif output thanks to Thomas Boutell (see acknowledgment at bottom.)</LI></P>
<P ALIGN="JUSTIFY"><LI>Scanning a set of parameters across a range of values.</LI></P>
<P ALIGN="JUSTIFY"><LI>Automatic optimization of a set of parameters to minimize deformation.</LI></P>
<P ALIGN="JUSTIFY"><LI>Advanced optimization using a basis set of deformations to determine the error of a given configuration as a linear sum of the basis.  This feature was inspired by reading Luc Arnold's paper. Luc actually uses analytical models, but his paper inspired the idea of optimization, and decomposing the problem into a linearly weighted sum of a basis set.</LI></P></UL>

<P ALIGN="JUSTIFY">The rest of this document describes how to run Plop, and the kinds of information that you can give Plop to control its operation.</P>
<P ALIGN="JUSTIFY">Plop requires about 8MB to run moderate size problems, and 32MB for larger problems. Plop dynamically allocates most memory, but has an upper bound on the number of points in the mesh. The default is 2000 points, and can be adjusted using the <B>-a</B> flag (see below.)</P>
<P ALIGN="JUSTIFY">In addition to Plop, which is an integrated package, there are three separate programs that, called <B>grid_gen</B>, <B>plate</B>, and <B>plot</B>, that can perform the various functions independently. Grid_gen will generate a mesh. Plate is a modification of Toshimi Taki's code, and performs the finite element method, but uses sparse matrix methods to speed up the computation. Plot will produce a graphical output of the results. These are not documented here.</P>
<OL>

</FONT><FONT FACE="Arial Black" COLOR="#ffffff"><LI>Basics of FEM</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">In order to understand what Plop does, and in particular how to use some of the more advanced features, it is useful to have a basic idea of how FEM is used to analyze a mirror cell. The deformation of the mirror can be computed by numerically solving a partial differential equation. The differential equation describes the deformation of each point on the mirror's surface as a function of the thickness, stiffness, mass, and supports. To solve this, it is necessary to break up the mirror into a set of small segments, each of which is a triangle. This set of triangles is referred to as the mesh. Each triangle is defined by the location of the three points at its corners. We also need to compute the weight of each segment. The mirror cell supports provide a set of forces at some of the triangle corner points. In order to precisely model the configuration, it is necessary to make sure that each support coincides exactly with one of the points associated with some triangles. This task, called mesh generation, is the first part of Plop's job, and can be performed by a separate program called grid_gen.</P>
<P ALIGN="JUSTIFY">Here is an example mesh generated by Plop for a typical support. This is for a 9-point cell. Each of the support points is circled. Note how Plop tries to keep the size of each of the mesh triangles approximately the same throughout the entire mesh.</P>
<P ALIGN="JUSTIFY"><IMG SRC="Image1.gif" WIDTH=571 HEIGHT=531></P>
<P ALIGN="JUSTIFY">Plate is then used to perform FEM, which solves the differential equation and produces a number for each of the triangle corner points indicating how much it is deflected by the forces on the mirror.</P>
<P ALIGN="JUSTIFY">Plop uses these results, and calculates the surface error resulting from the deformations. It can either compute RMS error, which is more common, or peak to valley (P-V) error. Plop can use either the deformations directly as they result from the FEM, or it can find the best parabola that minimizes RMS error, and subtract that from the error. This is equivalent to the user refocusing the telescope to find the best focus point.</P>
<P ALIGN="JUSTIFY">All units used in Plop are millimeters (mm.)</P>
<B><I><P ALIGN="JUSTIFY">Fine Point: </B></I>Error calculation is something that requires a careful analysis. The most obvious method is simply to compute the error at each of the mesh points, and to be careful, weight each of these displacements of these by the size of the triangle. This is not very good, because there are typically few mesh points, and the deformation is actually a continuous function across this surface. This means that the error that is measured can take huge jumps for relatively small changes in the geometry, and makes the optimizer's task difficult. It also typically understates the error, so it is necessary to use many mesh points, which takes a large CPU time, to obtain an accurate estimate. </P>
<P ALIGN="JUSTIFY">Plop avoids this by using a more detailed estimate. It breaks each of the mesh triangles into 25 smaller error triangles, and measures the displacement of each of these. It uses linear interpolation across the mesh triangles to estimate the displacement at the corners of the error triangles. This eliminates problems that used to occur in early versions of Plop with the optimizer not converging. </P><OL>

<OL>

</FONT><FONT FACE="Arial Black" SIZE=2><LI>Running Plop</LI></OL>

</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Plop is presently a console mode program running under Windows-95. It evolved from a Unix environment, where it was convenient to use it in this manner because of the more powerful shells. Under Windows, it is somewhat clumsier to use it, so it may evolve into a GUI program. To run it, you can use either the MS-DOS command window, or type a command into the Run window. The command should be of the form:</P>
<P ALIGN="JUSTIFY">plop.exe [<I>options</I>] <I>input_file</P>
</I><P ALIGN="JUSTIFY">You will need to specify appropriate path names, and possibly want to redirect the output to a file.</P>
<P ALIGN="JUSTIFY">You can run Plop without providing any arguments, in which case it will prompt you for them. </P>
<P ALIGN="JUSTIFY">The specification of the analysis to be performed is described in a file that contains a description of the mirror, the cell, and the types and ranges for the analyses to be performed. The optional options control various options such as refocusing, the format of the output, debugging, and producing a picture of the result.</P>
<P ALIGN="JUSTIFY">The convention is that the analysis file has the extension ".gr", which is short for grid (Plop was built in several pieces, the first of which was grid_gen, to automatically generate the mesh for Plate. This led to the .gr extension.)</P>
<P ALIGN="JUSTIFY">You can also run Plop by double-clicking it. This will prompt you for the options and the file name. </P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Format of the .gr file</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">The .gr file contains a sequence of lines, each of which specifies a parameter or command, or possibly a comment. Blank lines are allowed, and a line that starts with a ";" is considered a comment and is ignored. The easiest way to create a file is with any ASCII text editor such at notepad or wordpad, which can edit text files. The examples supplied on the disk are formatted using Unix  conventions, (LF only at end of a line) and notepad will produce a single line containing the whole file. It is better to use wordpad on these files.</P>
<P ALIGN="JUSTIFY">A parameter specification has a keyword specifying the parameter to be set, and one or more values associated with it. For example, one of the parameters is the diameter of the mirror. This is specified with the <B>diameter</B> keyword as follows:</P>
<P ALIGN="JUSTIFY">diameter 300</P>
<P ALIGN="JUSTIFY">Use standard scientific notation for floating point numbers, i.e. diameter 3e2 or diameter 3.0e2 would be acceptable.</P>
<P ALIGN="JUSTIFY">In the case that there are multiple numerical values associated with a parameter, they are listed consecutively, and separated by one or more blanks.</P>
<P ALIGN="JUSTIFY">The following set of keywords are used by plop:</P>
<B><P ALIGN="JUSTIFY">diameter, thickness, density, modulus, poisson, focal-length, f-ratio, sagitta, rel-sagitta, n-mesh-rings, support-radii, rel-support-radii, mesh-radii, rel-force, num-support, support-mesh-ring, support-angle, points-on-ring, obstruction-radius, rel-obs-radius, basis-ring-size, basis-ring-min, optimize, scan-set, scan-var</P>
</B><P ALIGN="JUSTIFY">Not all keywords are required. Sensible defaults are provided for some of the parameters.</P>
<P ALIGN="JUSTIFY">Many of the parameters describe linear dimensions. The units of all linear dimensions are mm. In case you forget, one inch is exactly 25.4 mm.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Physical Properties of the Mirror  Material</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">The <B>density</B> keyword specifies the density in kg/mm^3. The <B>modulus</B> keyword gives the Young's modulus. The <B>poisson</B> keyword gives the Poisson ratio of the material. These default to Pyrex 7740, with values 2.23e-6, 6400, and 0.2.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Geometry of the Mirror</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">You must specify the diameter, thickness, and focal length of the mirror.</P>
<P ALIGN="JUSTIFY">Use the <B>diameter</B> keyword to specify the diameter.</P>
<P ALIGN="JUSTIFY">Use the <B>thickness</B> keyword to specify the thickness at the edge of the mirror.</P>
<P ALIGN="JUSTIFY">Plate, the FEM solver in Plop, is based on plate theory. This means that the mirror should be thin compared to its diameter. Specifically, the thickness should be no more than 20% of the diameter.</P>
<P ALIGN="JUSTIFY">Use one of  the keywords <B>focal</B>-<B>length</B>, <B>f-ratio</B>, <B>sagitta</B>, and <B>rel-sagitta</B> to specify the focal length. The <B>focal-length</B> keyword gives the absolute dimension of the focal length. The <B>f-ratio</B> keyword specifies the focal length as an f-ratio. The <B>sagitta</B> keyword specifies the focal length as an absolute measurement of the sagitta of the mirror. The <B>rel-sagitta</B> keyword gives the sagitta of the mirror as a ratio of the absolute sagitta divided by the edge thickness of the mirror.</P>
<P ALIGN="JUSTIFY">This apparent excess of ways to specify a single parameter is more useful than it seems at this point. The reason is that one may want to analyze a set of mirrors, and hold some parameter constant across the range of analyses. For instance, you might want to analyze a set of f/6 mirrors for various diameters, or to analyze a set of mirrors in which the sagitta is 5% of the edge thickness. Choosing the appropriate keyword from the above list will let you hold the corresponding geometrical ratio constant.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Secondary Mirror Obstruction</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">The secondary mirror obstructs the primary mirror, and the obstructed part of the primary mirror should be ignored from the error calculations. Arnold showed that this can affect the best choice of supports for the mirror. You can tell Plop the size of the secondary mirror, or its size relative to the primary mirror, by using either the <B>obstruction-radius</B> or <B>rel-obs-radius</B> keywords. The obstruction-radius keyword specifies the radius of the secondary. The <B>rel-obs-radius</B> keyword specifies the ratio of the radius of the secondary to the radius of the primary. Note that the secondary is specified in terms of radius, not diameter. For the ratio, you can choose to think of the ratio of either the radii or the diameters, since they are equal. For example, a 300 mm diameter mirror with a 45 mm diameter secondary could be described with either of  the following:</P>
<P ALIGN="JUSTIFY">obstruction-radius 22.5</P>
<P ALIGN="JUSTIFY">rel-obs-radius  .15</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Geometry of the Mirror Cell</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">This section begins with a description of the kinds of mirror cells that Plop can model.</P>
<P ALIGN="JUSTIFY">A mirror cell provides a set of supports for the mirror, each one of which exerts some force at what is essentially a single point on the mirror.</P>
<P ALIGN="JUSTIFY">The support points must be described in a certain framework that corresponds to common mirror cells. The supports are arranged in a set of rings, called support rings. Each support ring contains some number of supports at a given radius. The supports are spaced around the ring at equal angles, so the number of supports defines the angle between the supports. The angle at which the first support occurs is the only other piece of information that must be defined in order to complete the specification.</P>
<P ALIGN="JUSTIFY">Consider a typical 9-point support for a 300 mm mirror. It might have 3 supports at radius 45mm, and 6 supports at radius 120 mm. The <B>num-support</B> keyword is used to define the number of supports in each mesh ring. The inner ring has supports at angles 0,120, and 240 degrees, and the outer one has supports at angles 30,90,150,210,270, and 330 degrees. This corresponds to the picture above. The keywords <B>support-radii</B> and <B>support-angle</B> are used to describe the radii and the angle of the fist support in each ring. Each must contain one number for each ring of supports in the cell. The description is:</P>
<P ALIGN="JUSTIFY">num-support 3 6</P>
<P ALIGN="JUSTIFY">support-radii 45 120</P>
<P ALIGN="JUSTIFY">support-angle 0 30</P>
<P ALIGN="JUSTIFY">It is also common to want to describe a cell in terms of the ratio of the support ring radius compared to the radius of the mirror. This is useful in examining the properties of a set of cells with the same relative configuration. The <B>rel-support-radii</B> keyword describes the radius of the supports divided by the radius of the mirror. The following statement could also be used to describe the example cell above.</P>
<P ALIGN="JUSTIFY">rel-support-radii .3 .8</P>
<P ALIGN="JUSTIFY">There are some important considerations for generating the mesh from the support configuration. Plop insists that each support point be located at the corner of a triangle. It also makes the triangles a uniform size around each ring. Most inconveniently, it requires that the first point be at angle 0. This means that it is important that the angle of the first support be divisible into 360 degrees. For example, if the first support is at 30 degrees, we can uses as few as 12 triangles around the ring at that point. On the other hand, if the first support is at 1 degree, it will be necessary to have 360 triangles around the ring at that point in the mesh. </P>
<P ALIGN="JUSTIFY">This can be avoided by using the basis generation method described later, but this is best left until you have a good understanding of  Plop's operation.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Forces on Mirror Cell Supports</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">By default, each of the supports in the mirror cell has the same supporting force. Plop allows you to specify forces that are different for each support using the <B>rel-force</B> keyword. This has the following format:</P>
<P ALIGN="JUSTIFY">rel-force num1 num2 num3 …</P>
<P ALIGN="JUSTIFY">Each of the numbers corresponds with one support ring. There must be exactly as many numbers as there are support rings. The numbers are arbitrary units. The force associated with a given support is computed according to the number given for that ring, divided by the total of all the numbers.  For example, if a 9 point support should have 1.5 times as much force in each of the outer ring of 6 supports as the each of the 3 supports in the inner ring, the following would be used:</P>
<P ALIGN="JUSTIFY">rel-force 1 1.5</P>
<P ALIGN="JUSTIFY">The statement</P>
<P ALIGN="JUSTIFY">rel-force 2 3</P>
<P ALIGN="JUSTIFY">is also equivalent, since the ratio of the numbers is identical. In both cases, the supports on the inner ring would have 1/(3*1+6*1.5)= 0.08333 of the total force, and the supports on the outer ring would have 1.5(3*1+6*1.5)=0.125 of the total force.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Mesh Generation Parameters</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">You must tell Plop how fine a mesh to generate. Plop constructs the mesh by constructing a set of rings of various radii, and filling each ring with triangles. The number of triangles is arranged such that support points line up with a triangle point, and to ensure reasonably size triangles. In the absence of other constraints, Plop will use <IMG SRC="Image2.gif" WIDTH=40 HEIGHT=21> points around a mesh ring by default, such that the <I>i</I>th ring contains at least <IMG SRC="Image3.gif" WIDTH=30 HEIGHT=18>points. Typically, this means the number of points is 1, 6, 12, 12, 24, 24, etc. For configurations that cannot fit into this, Plop will vary the number of mesh points to align with the support points. All that the user needs to specify is number of mesh rings. This is done with the <B>n-mesh-rings</B> keyword. This describes the number of rings of points on the mesh. Since each triangle is between two mesh rings, the number of rings of triangles will be one fewer. In the example above, n-mesh-rings is set to 8, and there are 7 rings of triangles. This is done with the following line:</P>
<P ALIGN="JUSTIFY">n-mesh-rings 8</P>
<P ALIGN="JUSTIFY">For most common analyses, specifying the number of mesh rings will be sufficient, but optimization requires that careful attention be paid to the details of associating mesh rings with supports.</P>
<P ALIGN="JUSTIFY">As a guideline, the following number of mesh rings are recommended as minimums for various types of mirror cells.</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=372>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Cell Type</FONT></TD>
<TD WIDTH="69%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Minimum number of Mesh Rings Required</FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">3 point</FONT></TD>
<TD WIDTH="69%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">8</FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">6 point</FONT></TD>
<TD WIDTH="69%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">11</FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">9 point</FONT></TD>
<TD WIDTH="69%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">11</FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">18 point</FONT></TD>
<TD WIDTH="69%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">17</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Scanning Parameters</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Plop contains facilities to allow you to scan one or more parameters across a range. This is useful for conducting studies across a range of values without having to edit a separate .gr file for each analysis. For example, you may want to determine the deformation for 10 different mirror diameters, and for each one of those, study 10 different focal lengths. Considering the combinations of diameters and focal length, there are 100 separate analyses that need to be performed. Using two Plop commands can perform all of these analyses from a single .gr file.</P>
<P ALIGN="JUSTIFY">There are two different methods for scanning a range of parameters. The first, <B>scan-var</B>, performs the analysis of a parameter for a set of equally spaced values. The format is as follows:</P>
<P ALIGN="JUSTIFY">scan-var parm-name [index]  start-value end-value step-ratio</P>
<P ALIGN="JUSTIFY">The [<I>index</I>] indicates an optional value of <I>index</I>. The <I>parm-name </I>is the keyword that describes the parameter that you wish to vary. If the parameter is a vector, that can contain more than one value, such as support-radii, then the <I>index </I>must be present, and indicates which one of the elements of the vector is to be scanned. The index must be present even if the vector only contains a single value. Any parameter that can meaningfully be a floating point value may be scanned. Also, if the scanned parameter is a vector, then all of the vector must be initialized with the corresponding keyword. If, on the other hand, the scanned parameter is a scalar, there is no need to initialize it using its keyword. This is to because the scan will necessarily set a scalar value, but might not set all of the values in a vector parameter.</P>
<P ALIGN="JUSTIFY">Parameters such as num-supports and other values that must be integers cannot be scanned. The starting and end values are given by <I>start-value </I>and<I> end-value</I> respectively. The step size is determined by dividing the distance between the end and starting points by the integer specified in <I>step-ratio. </I>Note that this means that the number of steps is always one greater than <I>step-ratio. </I>For example, if you wanted to perform an analysis of all mirrors from 100 to 200 mm in diameter, with at 20 mm step size, you could use the following:</P>
<P ALIGN="JUSTIFY">scan-var diameter 100 200 5</P>
<P ALIGN="JUSTIFY">This performs 6 analyses at 100,120,140,160,180, and 200 mm diameters.  Similarly, to scan the radius of the inner support ring on a 9 point support from 30mm to 60 mm using a 5mm step, the following would be used:</P>
<P ALIGN="JUSTIFY">scan-var support-radius 0 30 60 6</P>
<P ALIGN="JUSTIFY">Note the 0 index to indicate that it is support-radius 0 to be scanned, while the diameter scan does not require an index.</P>
<P ALIGN="JUSTIFY">Plop allows non-uniform steps, using the <B>scan-set</B> keyword. The format is:</P>
<P ALIGN="JUSTIFY">scan-set parm-name value1 value2 value3 …</P>
<P ALIGN="JUSTIFY">In this command, you explicitly specify the values of  the parameter for each analysis. For example, if you want to examine f/4, f/4.5, f/5 and f/6 mirrors, you could use the following:</P>
<P ALIGN="JUSTIFY">scan-set f-ratio 4 4.5 5 6</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Order of Scanning</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Optimization</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">One of  the most powerful features of  Plop is its ability to automatically optimize the design of a mirror cell to minimize the surface error. The <B>optimize</B> keyword instructs Plop to vary a parameter until the smallest error is found. The syntax is as follows:</P>
<P ALIGN="JUSTIFY">optimize parm-name [index] step_max</P>
<P ALIGN="JUSTIFY">As the case in the scan keywords, <I>parm-name</I> and the optional <I>index </I>specify the parameter that should be optimized. The <I>step-size</I> is the maximum change of the parameter that Plop should make in a single optimization step. This should be chosen to be small compared to the expected value of the parameter that you are optimizing. For example, we usually use <B>rel-support-radii</B> to express the supports' radii relative to the radius of the mirror. We expect that 0.02 of the radius is sufficiently small compared to the relative radius of the supports.</P>
<P ALIGN="JUSTIFY">Plop will iterate until the change from one analysis to the next is about 1e-4 times the value of the <I>step_max </I>parameter, or 0.01%, or until the change in error between iterations is 1e-9 times the error.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Interaction and Ordering of Scanning and Optimization</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Optimization and scanning can both be performed within a single .gr file. This means that some of the parameters are scanned, and for each such value, the optimization is performed to determine the best value of the optimization parameters. It is easy to write a single .gr file that, for every diameter and every focal length, finds the best location of the supports. Here is a fragment of the .gr file to do so:</P>
<P ALIGN="JUSTIFY">scan-var diameter 100 200 10</P>
<P ALIGN="JUSTIFY">scan-set f-ratio 4 4.5 5 6</P>
<P ALIGN="JUSTIFY">optimize support-radii 0 .02</P>
<P ALIGN="JUSTIFY"> </P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Advanced Mesh Generation Parameters</LI></OL>

</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">You probably do not want to read this section.</P>
<P ALIGN="JUSTIFY">Plop will usually be able to generate the mesh given only the radii of the supports and the number of mesh rings. However, the algorithm for mapping the supports to various rings on the mesh rings may fail if you give it a peculiar mirror cell configuration. In particular, if the supports are at very close radii, it may not be able to find a mesh ring for every support. In this case, you need to tell Plop the radii of the mesh rings, and which mesh ring is to be used for each of the support rings. The mesh-radii keyword is used together with a vector of the radii at which the mesh rings are located. The support-mesh-ring  keyword specifies which of the mesh rings is to be used for the supports. For example:</P>
<P ALIGN="JUSTIFY">mesh-radii 0 20 40 60 80 100</P>
<P ALIGN="JUSTIFY">support-mesh-ring 2</P>
<P ALIGN="JUSTIFY">would be used if  you wanted 6 mesh rings and a single ring of supports at radius 40.</P>
<P ALIGN="JUSTIFY">This is not terribly likely to be useful, but you were warned.</P>
</FONT><FONT FACE="Arial Black" COLOR="#ffffff"><LI>Control Options for Plop</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Operation of Plop is controlled by a set of flags supplied at the command line, or at the prompt if you start Plop without any arguments. The options available are listed below, and the detailed description of each in subsequent sections. The arguments start with a '-' if you put them in the command line. Do not use the '-' if you are typing them as commands to a prompt from Plop.</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#008000" CELLPADDING=7 WIDTH=307>
<TR><TD WIDTH="34%" VALIGN="MIDDLE">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Flag</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Meaning</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-a <I>n</I></FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">maximum mesh points</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-b</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">verbose</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-c[n <I>num</I>]</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">contour plots</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-d <I>file</I></FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">generate Plate data file</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-g <I>name</I></FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">mesh generation strategy</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-m <I>file</I></FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">generate picture of mesh</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-n <I>num</I></FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">number of colours to use in plots</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-o</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">trace progress of optimizer</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-p <I>file</I></FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">plot map of deformation</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-q</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">quiet mode</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-r</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">toggle refocus</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-s <I>num</I></FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">size of picture</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-u</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">reuse best optimizer result</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-v</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">use P-V error measure</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-w <I>name</I></FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">save result of optimizer</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-z <I>num</I></FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">z range for colors in picture</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">-D <I>name</I></FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">debugging</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">x</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">run Plop (prompt mode only)</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY"></P>
<OL>

</FONT><FONT FACE="Arial Black" SIZE=3><LI>Allocation</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Plop allows 2000 mesh points by default. There can be up to 3 times as many triangles as there are points. Most of the memory in reasonable size problems is used for storing matrix elements. This is allocated in 500KB  chunks, and Plop can allocate a full 32 bit address space of elements. The <B>-a</B> argument can be used to adjust the number of mesh points allowed according to the size of your machine and the demands of the problem. The argument gives the maximum number of mesh points. Plop will advise you if you run out of space.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Verbose Mode</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Use the <B>-b</B> flag to obtain some information about the size of the mesh when generating the mesh.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Contour Flag</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">When plotting the deformation, use the <B>-c</B> flag to specify that a contour plot should be generated. The default is a color plot. Use the <B>-cn</B> flag with a number to specify the number of contours.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Print Plate Data</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">When running a single FEM, use the <B>-d</B> flag to print the results of Plate in a file. This is in Toshimi's format.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Mesh Generation Strategies</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">One of the most powerful features of Plop is automatic optimization of mirror cells. Optimization is a intricate procedure that requires some understanding in order to apply it and obtain good results. One of the critical issues is the way that supports are placed at mesh points. When a mesh is generated, Plop will enforce the placement of the supports on mesh rings to coincide with the radii of the mesh rings. It does so by finding a good fit between the number of mesh rings between adjacent supports that tends to equalize the size of the mesh rings. For example, consider a simple cell with one ring of supports, and a mesh that has 5 rings. Ideally, we would like to place the mesh rings at relative radii 0, 0.25, 0.50, 0.75, and 1.0. In the presence of supports that are not located at one of these radii, Plop sets one of the radii to coincide with the supports, and adjusts the spacing of the remaining rings to allocate equal space to each ring. There must always be a mesh ring at 0 and a ring at 1, so there are only 3 mesh rings that can be placed at any given location. For example, if we want the support at 0.4, the nearest uniformly spaced ring would be ring 2, at 0.5. Plop will therefore assign the support to ring 2, and set ring 2 to be located at 0.4. It will divide the remaining space among the rings evenly, and place ring 1 inside the support ring at 0.2, and ring 3 outside the support ring at 0.7. In another circumstance, if the support is to be at 0.35, the closest uniformly spaced ring is ring 1, so Plop will choose to place a ring at 0.35, but to put all other rings outside. Ring 0 will still be at 0, ring 4 at 1.0 and the remaining rings will be at 0.57,and 0.88.</P>
<P ALIGN="JUSTIFY">The reason that it is necessary to understand mesh generation when performing optimization is because a key requirement of optimization is that the error function vary smoothly with the parameters that are being optimized. As long as a support is associated with a given mesh ring, the error will vary smoothly with the radius of the support. However, as a support is moved to a location that causes it to be associated with a different ring, then the numerical error of the FEM may jump, even though the actual error will not do so. If the error is plotted as some parameter is varied smoothly, the error curve will be smooth, with the exception of discrete jumps as Plop moves the supports from one mesh ring to another.</P>
<P ALIGN="JUSTIFY">This can cause mildly confusing results when plotting scans of parameters, but the error is typically small. The difficulty is that the optimizer has no insight into discrete jumps in an otherwise smooth curve, but simply compares the error at one point to the error at another point. The optimizer can become hopelessly confused as a result of these jumps.</P>
<P ALIGN="JUSTIFY">Since the jumps occur as a result of moving the supports in discrete steps from one ring to another, there are basically two approaches to avoiding this problem: (1) place each support ring on some mesh ring at the beginning of the optimization, and don't move it thereafter, and (2) move the supports smoothly from one ring to another. In (1), the ring number that is used for support will remain fixed across multiple FEMs. In the above example, if the support was initially at 0.4, ring 2 would be used. It would continue to be used for subsequent FEMs, so that if the support had later been moved to 0.35, the remaining rings would be uniformly spaced a 0, 0.175, 0.675, and 1. If the support rings are moved a long ways from their starting position, large numerical errors can occur due to the distorted size of the mesh rings.</P>
<P ALIGN="JUSTIFY">In (2) fix the rings are fixed at their uniformly spaced locations, and Plop is used to perform 5 different FEMs, one for placing the support ring at each mesh ring. A subsequent analysis that places a support at a location between these uniformly spaced  mesh rings is handled by using a weighted sum of the results. For example, the analysis of the support ring at 0.4 would use .6 of the displacement resulting from the support at 0.5, plus 0.4 of the displacement resulting from the support at 0.25. This method is called the basis method, where a basis set of FEMs are performed, and all subsequent support configurations are derived from the basis set of FEMs. This method is extremely fast because it is possible to perform several FEMs using the same mesh, but different supports, nearly as fast as performing a single FEM. Each additional support analysis can take less thant 1% of the time for the first analysis. Essentially, in the time required to perform a single FEM, any number of subsequent analyses can be performed.</P>
<P ALIGN="JUSTIFY">The disadvantage is that the supports are now modeled essentially as being spread across two rings, when in fact we would like to model them as point supports. However, because of the speed of the basis method, it is possible to use very large meshes, with 1,000 or more triangles, reducing the spreading out of the force. Of course, the supports are not actually points, so the truth lies somewhere inbetween.</P>
<P ALIGN="JUSTIFY">Plop provides various strategies that perform both (1) and (2) at various levels. These are controlled by the grid-gen strategy argument to Plop. This has one of six possible values: <B>never</B>, <B>always</B>, <B>once</B>, <B>twice</B>, <B>first</B>, and <B>basis</B>. The default is <B>always</B>. The number of these strategies is evidence of the difficulty in finding a good strategy to handle mesh generation. The differences in the strategies are primarily related to the interaction of scanning and optimization. Only the basis strategy uses weighted sums of the basis; the remainder perform one FEM for each error analysis, but the details of the mapping between supports and mesh rings differ. The basis strategy is likely the best, as well as the fastest, but requires more skill to compose the problem.</P>
<P ALIGN="JUSTIFY">Use the <B>always</B> method if your problem converges; if you have a complex problem with many parameters, or are obtaining poor results, use the <B>basis</B> method, which takes more care in setting up the problem, but is much faster.</P>
<P ALIGN="JUSTIFY">To specify the generation strategy, use the <B>-g</B> flag followed by one or more spaces and the name of the mesh generation strategy. Each of the strategies is outlined below. All of the strategies except basis perform a FEM for every analysis.</P>
<OL>

</FONT><FONT FACE="Arial Black" SIZE=2><LI>-g always</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Map supports to rings for every analysis. This is the default.</P>
</FONT><FONT FACE="Arial Black" SIZE=2><LI>-g never</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Map supports to rings for the first analysis, and reuse this mapping for every subsequent FEM.</P>
</FONT><FONT FACE="Arial Black" SIZE=2><LI>-g first</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">For each optimization that is performed, map the supports to rings for the first FEM of that optimization, and reuse that mapping for every subsequent FEM in that optimization. This will help make sure that the optimizer does not encounter discontinuities, but will adjust the mapping to a better fit between optimizations.</P>
</FONT><FONT FACE="Arial Black" SIZE=2><LI>-g twice</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">For each optimization, map the supports to rings on the first FEM, then reuse this mapping for subsequent FEMs. After finding the optimum, perform another mapping and optimize using more FEMs using the new mapping to find a new optimum. This makes sure that Plop uses a mapping that is near to the one at the optimum, but can take a long time, or go off track if the first mapping leads to a bad solution.</P>
</FONT><FONT FACE="Arial Black" SIZE=2><LI>- g once</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">This is similar to -g twice, in that it does the first optimization twice, but then never changes the mapping for that optimization, or for any subsequent optimizations.</P>
</FONT><FONT FACE="Arial Black" SIZE=2><LI>-g basis</LI></OL>

</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">This is the most complex to use, and requires using the <B>basis-ring-size</B> and <B>basis-ring-min</B> keywords in the Plop .gr file. This specifies that Plop should generate a basis for each distinct physical configuration, and then use that basis to find the error of any configuration that can be derived from it.</P>
<P ALIGN="JUSTIFY">A configuration can be derived from a basis as long as the physical geometry does not change - for example, the diameter, thickness, focal length, and physical properties of the material. If these change between analyses, Plop will perform a FEM to regenerate the basis.</P>
<P ALIGN="JUSTIFY">Plop generates a basis by considering the placement of the supports at each of the mesh rings. Complexity arises from the fact that there may be a different number of supports in each ring of supports. This complicates mesh generation, which normally ensures that the number of points on each mesh ring is an integral multiple of the number of supports that are located on that ring.</P>
<P ALIGN="JUSTIFY">For example, consider an 27-point cell with 3 rings of supports, with 6, 9, and 12 supports in the rings. In order to form the basis for all of these, there must be at least 36 points on each mesh ring (36 is the least common multiple of 6, 9, and 12.) This is a large number for the inner rings and is not necessary for accuracy. Plop provides the capability of using fewer points than the number of points on a support ring. Plop will allow a support ring to be modeled as a set of points that divides the number of supports. In this example, Plop could use a basis set that had only 3 support point in each mesh ring. The 6 support ring would be modeled as two of the 3-point rings, one aligned with the 6-support ring, and the second rotated by an extra 60 degrees compared to the first ring. The 9 point ring would be modeled as three contributions rotated by 0, 40, and 80 degrees respectively. The 12 point ring would be modeled as four contributions.</P>
<P ALIGN="JUSTIFY">To speed up the computation, it is advantageous to break each support ring into as few components as possible. This can be done, if it is known that the rings with a larger number of supports will only be used beyond some minimum ring number, at locations where they will not cause an increase in the number of mesh points used for the ring. In this example, it is likely that the 12-point support ring will only occur in the outer few mesh rings, so it is reasonable to use 36 mesh points in these rings.</P>
<P ALIGN="JUSTIFY">The purpose of the <B>basis-ring-size</B> and <B>basis-ring-min</B> keywords is to specify the number of support points that will be analysed at each ring beyond a given mesh ring number. The <B>basis-ring-size </B>specifies the number of support points that will be used in each support ring used for basis generation. The <B>basis-ring-min</B> specifies the minimum mesh ring number to which the corresponding <B>basis-ring-size </B>applies. For the above example, we might decide to use basis support rings of 3, 6, and 9 to minimize the computation. We might decide to only use the 9-point mesh at rings 3 and higher, assuming a 8 ring mesh. This would be done with the following:</P>
<P ALIGN="JUSTIFY">basis-ring-size 6 9 12</P>
<P ALIGN="JUSTIFY">basis-ring-min 0 0 3</P>
<P ALIGN="JUSTIFY">Using this configuration, the basis would be generated using 8 analyses for the 6-support, 8 analyses for the 9-support, and 5 analysis for the 12-support. Each analysis would be decomposed into a weighted sum of the results of the basis analyses. </P>
<P ALIGN="JUSTIFY">It is possible to use fewer points in the basis set than there are supports in the cell. Plop can decompose a support ring into a sum of smaller rings. It can also accommodate rotations that are off the mesh. For example, it would be possible to rotate the 9-point ring by one degree without necessitating the use of 360 mesh points, as is done with the other forms of analysis.</P>
<P ALIGN="JUSTIFY">The basis strategy for mesh generation is presently the best for optimization. A side effect of using the basis is that the error varies smoothly as the support positions are changed. However, Plop at present requires that the user input the <B>basis-ring-size</B> and <B>basis-ring-min</B> parameters as described above, which are somewhat complicated to understand. The simplest way to generate these parameters is to use the number of supports as the basis-ring-size, and to set the basis-ring-min to numbers increase slowly </P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Generate Picture of Mesh</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">For a single analysis, use <B>-m</B> <I>file</I> to save a picture of the mesh in the file. This is a .gif file.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Number of Colors for Plot</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">To change the number of colors used for the plot, use the <B>-n</B> <I>num</I> flag. The default is 200 for color plots. Decreasing this to 10 or 20 leads to something that looks more like a color contour plot.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Trace Optimizer</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Plop will only print the results of the best solution found for an optimization problem. You can watch the optimizer try various configurations and the error result for each by using the <B>-o</B> flag.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Plot Map of Deformation</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Use the <B>-p</B> <I>file</I> flag to store a picture of the deformation in the file. This is a .gif file.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Quiet Mode</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">For each analysis or optimization, Plop will print out a line that begins with "results:" and contains the names of all of the parameters being optimized, followed by the error. This is easy to read, but may be hard to import into another tool to produce a plot or a table. To print a concise version of the output that only contains the numeric fields, use the <B>-q</B> option.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Refocus Flag and Error Measures</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">The error due to deformation of the mirror will often exceed the actual error encountered in use of the mirror. This is because the user will focus the system to obtain the clearest image. To model this, Plop can refocus the deformation by finding the parabola that best fits the deformation. Plop then subtracts out this parabola from the deformation computed by Plop. This can dramatically reduce the error, and change the best way to support the mirror. See the web page.</P>
<P ALIGN="JUSTIFY">Plop does refocusing by default. If you do not want to refocus, use the <B>-r</B> flag to toggle it.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Size of Plot</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">The plot is 500 pixels square by default. To change it, use the <B>-s</B> <I>num</I> flag with a number to specify the size of the picture.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Reuse Optimizer Result</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">In multiple optimizations, the results of an optimization will often be similar to previous ones, in particular if the appropriate relative dimensions are used instead of absolute ones.  To speed up the optimizer, it is helpful to begin the new search at the same place that the previous one ended. Plop will do this by default. To prevent this, use the <B>-u</B> option.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Use Peak to Valley  Error</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Plop calculates the error as RMS error. RMS error is typically about 0.2 or 0.25 of the peak-to-valley error. RMS error is considered to be a better measure as it includes the entire surface, while P-V only reflects the error at two extreme points in the surface.</P>
<P ALIGN="JUSTIFY">A reasonable limit for the RMS error due to the mirror cell is about 1/128 wave, which is about 4.2e-9 meter, or 4.2e-6 mm, for 550nm green light.</P>
<P ALIGN="JUSTIFY">Plop uses RMS error by default. To toggle the error metric, use the <B>-v </B>flag.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Save Result  of Optimizers</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Plop will print out the best result found during optimization, but if you want to save it as a .gr file, use the <B>-w</B> flag with the name of the file to save it in. (Note the recent publicity that split infinitives are just fine.)</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Z Range for Plots</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Plop will compute the colors so the range of colors or range of contours spans the entire range of values computed by the analysis. To make it easy to compare two different analyses using the same range of values in the plot, you can use the <B>-z</B> <I>num</I> flag. The number specifies the range of deformations that is mapped into the range of colors or contours on the plot, as appropriate.</P>
</FONT><FONT FACE="Arial Black" SIZE=3><LI>Debugging</LI></OL>

</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Debugging can be enabled by using <B>-D</B><I>name</I>, where <I>name</I> is one of <B>grid_gen</B>, <B>opt</B>, <B>basis</B>, <B>triangle</B>, or <B>interpolate</B>. If you need to use any of these, you should already have the source code and know why you want to.</P>
</FONT><FONT FACE="Arial Black" COLOR="#ffffff"><LI>Examples and Guidelines</LI>
</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">A number of examples are included with the software. These illustrate how to use Plop for various configurations.</P>
<P ALIGN="JUSTIFY">To help in determining the tradeoff of CPU time and memory versus accuracy, we ran the following experiment. A 9 point cell was evaluated using various numbers of mesh rings, using the basis method for error calculation. We measured CPU time, memory, and the predicted error. The following table lists all of these. The experiment was run on a 233MHz PII with 96MB of RAM. Note that this is for a FEM, and that using the basis method, each subsequent requires only a few percent of the time stated.</P>
<P ALIGN="JUSTIFY">The table shows several interesting properties, as we presume that analyses with more rings converge to the actual result. First, RMS error before refocusing converges quickly, so even 6 rings gives a result within 5% of the result for 35 rings. However, the error after refocus is the difference of two much larger numbers, and so the relative accuracy is much degraded. Be sure to note the 10X different scale factor between these two columns. The predicted RMS error after refocus for the 6 ring example is 17% smaller than the error of the 35 ring example. However, we only require 15 rings to come within 5% of the 35 ring result. It should also be noted that the error measure is still increasing at 35 rings, and may be slightly higher.</P></FONT>
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=590>
<TR><TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Mesh Rings</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">CPU Time (seconds)</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Memory (MB)</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Number of Points in Mesh</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">Number of Triangles in Mesh</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">RMS Error before Refocus (<IMG SRC="Image4.gif" WIDTH=30 HEIGHT=21> mm)</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">RMS Error after Refocusing (<IMG SRC="Image5.gif" WIDTH=30 HEIGHT=21>mm)</FONT></TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">6</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">1</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">1.5</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">115</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">180</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">8.19</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">8.26</FONT></TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">8</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">1</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">2</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">211</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">372</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">8.26</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">8.53</FONT></TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">10</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">3</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">3.1</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">355</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">612</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">8.48</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">8.95</FONT></TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">15</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">9</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">7.8</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">835</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">1572</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">8.54</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">9.52</FONT></TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">20</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">32</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">18.7</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">1603</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">3012</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">8.59</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">9.69</FONT></TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">25</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">98</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">36.9</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">2563</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">4932</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">8.60</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">9.81</FONT></TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">30</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">206</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">60.4</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">3525</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">6852</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">8.60</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">9.87</FONT></TD>
</TR>
<TR><TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">35</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">506</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">96.8</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">4867</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">9348</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">8.61</FONT></TD>
<TD WIDTH="14%" VALIGN="TOP">
<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">9.92</FONT></TD>
</TR>
</TABLE>

<FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Arial Black" COLOR="#ffffff"><LI>Acknowledgements</LI></OL>

</FONT><FONT FACE="Arial" SIZE=2><P ALIGN="JUSTIFY">The key computational component of Plop is Plate, written by Toshimi Taki. His contribution to Plop is extremely valuable, and core to the software.</P>
<P ALIGN="JUSTIFY">Richard Schwartz provided many useful references and suggestions that led to some of the ideas in Plop.</P>
<P ALIGN="JUSTIFY">Luc Arnold's paper provided valuable ideas for optimizing mirror cells.</P>
<P ALIGN="JUSTIFY">This code includes gd.c, written and distributed by Thomas Boutell, which requires the enclosed copyright notice. This applies only to the files gd.c, gd.h and mtable.c. </P>
<P ALIGN="JUSTIFY">Portions copyright 1994, 1995, 1996, 1997, 1998, by Cold Spring Harbor Laboratory. Funded under Grant P41-RR02188 by the National Institutes of Health.</P>
<P ALIGN="JUSTIFY">Portions copyright 1996, 1997, 1998, by Boutell.Com, Inc.</P>
<P ALIGN="JUSTIFY">GIF decompression code copyright 1990, 1991, 1993, by David Koblas (koblas@netcom.com).</P>
<P ALIGN="JUSTIFY">Non-LZW-based GIF compression code copyright 1998, by Hutchison Avenue Software Corporation (http://www.hasc.com/, info@hasc.com).</P>
<P ALIGN="JUSTIFY">Permission has been granted to copy and distribute gd in any context, including a commercial application, provided that this notice is present in user-accessible supporting documentation.     </P>
<P ALIGN="JUSTIFY">This does not affect your ownership of the derived work itself, and the intent is to assure proper credit for the authors of gd, not to interfere with your productive use of gd. If you have questions, ask. "Derived works" includes all programs that utilize the library. Credit must be given in user-accessible documentation.</P>
<P ALIGN="JUSTIFY">Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation. This software is provided "as is" without express or implied warranty.</P>
<P ALIGN="JUSTIFY">     </P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&nbsp;</P></FONT></BODY>
</HTML>
